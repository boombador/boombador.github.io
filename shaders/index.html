---
layout: basic
---
        
    <div id="container"></div>
        
    </body>
    <!-- Shaders -->
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float amplitude;
        attribute float displacement;
        varying vec3 vNormal;

        void main() {

        vNormal = normal;

        // multiply our displacement by
        // the amplitude. The amp will
        // get animated so we'll have
        // animated displacement
        vec3 newPosition =
            position + normal *
            vec3(displacement * amplitude);

        gl_Position = projectionMatrix *
                        modelViewMatrix *
                        vec4(newPosition, 1.0);
        }
    </script>
    
    <script type="x-shader/x-fragment" id="fragmentshader">
        // same name and type as VS
        varying vec3 vNormal;

        void main() {

        // calc the dot product and clamp
        // 0 -> 1 rather than -1 -> 1
        vec3 light = vec3(0.5, 0.2, 1.0);

        // ensure it's normalized
        light = normalize(light);

        // calculate the dot product of
        // the light to the vertex normal
        float dProd = max(0.0, dot(vNormal, light));

        // feed into our frag colour
        gl_FragColor = vec4(dProd, // R
                            dProd, // G
                            dProd, // B
                            1.0);  // A

        }
    </script>
    
    <!-- End Shaders -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
    <script src="/js/three.min.js"></script>
    
    <script type="text/javascript">
    // set the scene size
    var WIDTH = 400,
        HEIGHT = 300;
    
    // set some camera attributes
    var VIEW_ANGLE = 45,
        ASPECT = WIDTH / HEIGHT,
        NEAR = 0.1,
        FAR = 10000;

    // get the DOM element to attach to
    // - assume we've got jQuery to hand
    var $container = $('#container');

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(  VIEW_ANGLE, ASPECT, NEAR, FAR  );
    camera.position.z = 5;
    
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(WIDTH, HEIGHT);
    $container.append(renderer.domElement);

    var attributes = {
        displacement: {
            type: 'f', // a float
            value: [] // an empty array
        }
    };
    var uniforms = {
        amplitude: { type: 'f', value: 0 }
    } 

    // now populate the array of attributes
    var geometry = new THREE.SphereGeometry( 1, 32, 32 );
    var verts = geometry.vertices;
    var values = attributes.displacement.value;

    for (var v = 0; v < verts.length; v++) {
        values.push(Math.random() * 1);
    }
    var shaderMaterial = new THREE.ShaderMaterial({
        attributes:     attributes,
        uniforms:       uniforms,
        vertexShader:   $('#vertexshader').text(),
        fragmentShader: $('#fragmentshader').text()
    });
    var sphere = new THREE.Mesh( geometry, shaderMaterial );
    scene.add( sphere );

    var render = function () {
        requestAnimationFrame( render );

        sphere.rotation.x += 0.05;
        sphere.rotation.y += 0.05;

        renderer.render(scene, camera);
    };

    render();
    </script>
</html>

